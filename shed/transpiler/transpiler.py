"""
Transpiler transforms valid, but not able to be run python code, generated by retokenizer,
 to AST that can be executed.

It does so by getting build source AST and performing transformations on it.

---
After retokenizer processes source code, we have a python code with
 top-level 'statements' (`"ls"`) or autogenerated assign 'statements' (`__script_var_1 = "ls"`)
 in place of shell calls.
Transpiler goes through AST and transforms those statements into `subprocess` calls.

This step can theoretically be done in retokenizer,
 but it is much more convenient to do it at AST level, because:
1) AST is 'typed' and object-based, so inserting new stuff into it
 is much easier and less error-prone, then working directly with tokens
2) `ast` package provides tried-and-tested way of walking and manipulating python's AST,
 which we can use instead of writing our own implementation of it for tokens
3) Here we don't have too worry too much about padding and placing of stuff

If it was possible, I would write the whole program as one big AST transformer,
 but unfortunately AST can not be built from source
 that contains invalid syntax (for python) such as shell calls,
 so we still need to make changes in script's source with retokenizer.
"""

# pylint: disable=C0103

from ast import AST, Assign, Attribute, Call, Constant, Expr, Import, ImportFrom
from ast import List as ASTList
from ast import (
    Load,
    Module,
    Name,
    NodeTransformer,
    alias,
    copy_location,
    fix_missing_locations,
    iter_child_nodes,
    parse,
)
from typing import Any, List, Optional, Union

from ..config import __lang_name__
from .context import TranspilerContext
from .retokenizer import retokenize
from .utils import strip_shell_syntax


def transpile_source(script_source: str, context: Optional[TranspilerContext]) -> AST:
    if context is None:
        context = TranspilerContext()

    prepared_script = retokenize(script_source, context)
    return transpile_ast(parse(prepared_script), context)


IMPL_NAME = '__impl__'
impl_import = Import(names=[alias(name=f'{__lang_name__}._impl', asname=IMPL_NAME)])
std_import = ImportFrom(
    module=f'{__lang_name__}.std', names=[alias(name='*', asname=None)], level=0
)


# pylint: disable=too-many-public-methods
class ShellCallTransformer(NodeTransformer):
    current_node: AST

    def __init__(self, context: TranspilerContext):
        self.context = context

    def generic_visit(self, node: AST) -> Optional[AST]:
        # populate 'parent'
        for child in iter_child_nodes(node):
            child.parent = node  # type:ignore
        self.current_node = node

        node = super().generic_visit(node)
        return node

    def visit_Module(self, node: Module) -> Any:
        for index, imp in enumerate((impl_import, std_import)):
            node.body.insert(index, imp)
        return self.generic_visit(node)

    def parse_arg(self, val: str) -> Any:
        const = Constant(value=val, kind=None)
        if self.context.is_autogenerated(val):
            return self.create_impl_call('get_var', [const])
        return const

    def create_args_list(self, values: List[str]) -> ASTList:
        args = ASTList(elts=[self.parse_arg(val) for val in values], ctx=Load())
        return copy_location(args, self.current_node)

    def create_impl_call(
        self, func: str, args: List[Any], location_from: Optional[AST] = None
    ) -> Any:
        function = Attribute(value=Name(id=IMPL_NAME, ctx=Load()), ctx=Load(), attr=func)
        expr = Call(func=function, args=args, keywords=[])
        return copy_location(expr, location_from or self.current_node)

    def create_var_load(self, node: Constant) -> Any:
        return self.create_impl_call(
            'get_var', [Constant(value=strip_shell_syntax(node.value), kind=None)], node,
        )

    def create_subprocess_call(self, node: Union[Name, Constant], get_output: bool = True) -> Any:
        if isinstance(node, Name):
            values = [node.id]
        elif isinstance(node, Constant):
            values = strip_shell_syntax(node.value).split(' ')
        else:
            raise ValueError('Accepted nodes are Names and Constants')

        args = self.create_args_list(values)
        return self.create_impl_call('call', [args, Constant(value=get_output, kind=None)], node)

    def replace_with_call(self, node: Constant, get_output: bool = True) -> Any:
        if node.value.startswith('$('):
            return self.create_subprocess_call(node, get_output)
        if node.value.startswith('${'):
            return self.create_var_load(node)
        raise ValueError('Constants for replacement should be calls `$()` or var loads `${}`')

    @staticmethod
    def is_top_level_parent(node: AST) -> bool:
        return isinstance(node, Expr)

    @staticmethod
    def is_at_top_level(node: AST) -> bool:
        # either has a module as a parent, or as grandparent - then should be wrapped in Expr
        parent = getattr(node, 'parent', None)
        if ShellCallTransformer.is_top_level_parent(parent):
            return True
        if isinstance(parent, Expr):
            grandparent = getattr(parent, 'parent', None)
            if ShellCallTransformer.is_top_level_parent(grandparent):
                return True
        return False

    def visit_Name(self, node: Name) -> Any:
        # if Name or Constant is a top-level expr by itself - it should be a shell call
        if self.is_at_top_level(node):
            return self.create_subprocess_call(node, get_output=False)
        return node

    visit_Constant = visit_Name  # TODO: do we need any other checks?

    def visit_Assign(self, node: Assign) -> Any:
        # if assigning to autogenerated variable
        if len(node.targets) == 1 and self.context.is_autogenerated(
            node.targets[0].id  # type:ignore
        ):
            node.value = self.replace_with_call(node.value)  # type: ignore
        return node


def transpile_ast(script_ast: AST, context: Optional[TranspilerContext] = None) -> AST:
    if context is None:
        context = TranspilerContext()

    transformer = ShellCallTransformer(context)

    result_ast = transformer.visit(script_ast)
    fix_missing_locations(result_ast)

    return result_ast
