"""
Transpiler transforms valid, but not able to be run python code, generated by retokenizer,
 to AST that can be executed.

It does so by getting build source AST and performing transformations on it.

---
After retokenizer processes source code, we have a python code with
 top-level 'statements' (`"ls"`) or autogenerated assign 'statements' (`__script_var_1 = "ls"`)
 in place of shell calls.
Transpiler goes through AST and transforms those statements into `subprocess` calls.

This step can theoretically be done in retokenizer,
 but it is much more convenient to do it at AST level, because:
1) AST is 'typed' and object-based, so inserting new stuff into it
 is much easier and less error-prone, then working directly with tokens
2) `ast` package provides tried-and-tested way of walking and manipulating python's AST,
 which we can use instead of writing our own implementation of it for tokens
3) Here we don't have too worry too much about padding and placing of stuff

If it was possible, I would write the whole program as one big AST transformer,
 but unfortunately AST can not be built from source
 that contains invalid syntax (for python) such as shell calls,
 so we still need to make changes in script's source with retokenizer.
"""

# pylint: disable=C0103

from ast import AST, Assign, Attribute, Call, Constant, Expr, Import, ImportFrom
from ast import List as ASTList
from ast import (
    Load,
    Module,
    Name,
    NodeTransformer,
    alias,
    copy_location,
    fix_missing_locations,
    iter_child_nodes,
    parse,
)
from typing import Any, Optional, Union

from ..config import __lang_name__
from ..utils import console, print_center, print_line, title
from .context import TranspilerContext
from .retokenizer import retokenize


def transpile_source(script_source: str, context: Optional[TranspilerContext]) -> AST:
    if context is None:
        context = TranspilerContext()

    prepared_script = retokenize(script_source, context)

    if context.verbosity >= 2:  # type:ignore
        print_line()
        print_center(title('Retokenized'))
        console.print(prepared_script, highlight=False)

    return transpile_ast(parse(prepared_script), context)


SUBPROCESS_NAME = '__sb__'
subprocess_import = Import(names=[alias(name='subprocess', asname=SUBPROCESS_NAME)])
std_import = ImportFrom(module=f'{__lang_name__}.std', names=[alias(name='*')])
subprocess_import.lineno = 1
std_import.lineno = 2
subprocess_import.col_offset = std_import.col_offset = 1


class ShellCallTransformer(NodeTransformer):
    def __init__(self, context: TranspilerContext):
        self.context = context

    def generic_visit(self, node: AST) -> Optional[AST]:
        # populate 'parent'
        for child in iter_child_nodes(node):
            child.parent = node  # type:ignore
        return super().generic_visit(node)

    def visit_Module(self, node: Module) -> Any:
        node.body.insert(0, subprocess_import)
        node.body.insert(1, std_import)
        return self.generic_visit(node)

    @staticmethod
    def replace_with_call(node: Union[Name, Constant], get_output: bool = True) -> Any:
        # TODO: default pre-processing

        if isinstance(node, Name):
            values = [node.id]
        elif isinstance(node, Constant):
            values = node.value.split(' ')
        else:
            raise ValueError('Accepted nodes are Names and Constants')

        args = [ASTList(elts=[Constant(value=val, kind=None) for val in values], ctx=Load())]
        method = 'check_output' if get_output else 'call'  # TODO, FIXME: seems sketchy
        func = Attribute(value=Name(id=SUBPROCESS_NAME, ctx=Load()), ctx=Load(), attr=method)

        expr = Call(func=func, args=args, keywords=[])
        expr = copy_location(expr, node)

        return expr

    @staticmethod
    def is_top_level(node: AST) -> bool:
        if isinstance(node, Module):
            return True
        # either has a module as a parent, or as grandparent - then should be wrapped in Expr
        parent = getattr(node, 'parent', None)
        if isinstance(parent, Module):
            return True
        if isinstance(parent, Expr):
            grandparent = getattr(parent, 'parent', None)
            if isinstance(grandparent, Module):
                return True
        return False

    def visit_Name(self, node: Name) -> Any:
        # if Name or Constant is a top-level expr by itself - it should be a shell call
        if self.is_top_level(node):
            return self.replace_with_call(node, get_output=False)
        return node

    visit_Constant = visit_Name  # TODO: do we need any other checks?

    def visit_Assign(self, node: Assign) -> Any:
        # if assigning to autogenerated variable
        if len(node.targets) == 1 and node.targets[0].id.startswith(  # type:ignore
            self.context.prefix
        ):
            node.value = self.replace_with_call(node.value)  # type: ignore
        return node


def transpile_ast(script_ast: AST, context: Optional[TranspilerContext] = None) -> AST:
    if context is None:
        context = TranspilerContext()

    transformer = ShellCallTransformer(context)

    result_ast = transformer.visit(script_ast)
    fix_missing_locations(result_ast)

    return result_ast
